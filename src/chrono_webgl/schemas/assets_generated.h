// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ASSETS_CHRONO_WEBGL_H_
#define FLATBUFFERS_GENERATED_ASSETS_CHRONO_WEBGL_H_

#include "flatbuffers/flatbuffers.h"

#include "math_generated.h"

namespace chrono {
namespace webgl {

struct BoxShape;

struct SphereShape;

struct CylinderShape;

struct Texture;

struct Material;

struct CommandNewMaterial;

struct CommandModifyMaterial;

struct CommandNewShape;

struct CommandSetMaterial;

struct CommandLoadCache;

struct WebGLMessage;

struct WebGLMessageList;

enum AnyShape {
  AnyShape_NONE = 0,
  AnyShape_BoxShape = 1,
  AnyShape_SphereShape = 2,
  AnyShape_CylinderShape = 3,
  AnyShape_MIN = AnyShape_NONE,
  AnyShape_MAX = AnyShape_CylinderShape
};

inline const AnyShape (&EnumValuesAnyShape())[4] {
  static const AnyShape values[] = {
    AnyShape_NONE,
    AnyShape_BoxShape,
    AnyShape_SphereShape,
    AnyShape_CylinderShape
  };
  return values;
}

inline const char * const *EnumNamesAnyShape() {
  static const char * const names[] = {
    "NONE",
    "BoxShape",
    "SphereShape",
    "CylinderShape",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyShape(AnyShape e) {
  if (e < AnyShape_NONE || e > AnyShape_CylinderShape) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyShape()[index];
}

template<typename T> struct AnyShapeTraits {
  static const AnyShape enum_value = AnyShape_NONE;
};

template<> struct AnyShapeTraits<BoxShape> {
  static const AnyShape enum_value = AnyShape_BoxShape;
};

template<> struct AnyShapeTraits<SphereShape> {
  static const AnyShape enum_value = AnyShape_SphereShape;
};

template<> struct AnyShapeTraits<CylinderShape> {
  static const AnyShape enum_value = AnyShape_CylinderShape;
};

bool VerifyAnyShape(flatbuffers::Verifier &verifier, const void *obj, AnyShape type);
bool VerifyAnyShapeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum AnyCommand {
  AnyCommand_NONE = 0,
  AnyCommand_CommandLoadCache = 1,
  AnyCommand_CommandNewMaterial = 2,
  AnyCommand_CommandNewShape = 3,
  AnyCommand_MIN = AnyCommand_NONE,
  AnyCommand_MAX = AnyCommand_CommandNewShape
};

inline const AnyCommand (&EnumValuesAnyCommand())[4] {
  static const AnyCommand values[] = {
    AnyCommand_NONE,
    AnyCommand_CommandLoadCache,
    AnyCommand_CommandNewMaterial,
    AnyCommand_CommandNewShape
  };
  return values;
}

inline const char * const *EnumNamesAnyCommand() {
  static const char * const names[] = {
    "NONE",
    "CommandLoadCache",
    "CommandNewMaterial",
    "CommandNewShape",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyCommand(AnyCommand e) {
  if (e < AnyCommand_NONE || e > AnyCommand_CommandNewShape) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnyCommand()[index];
}

template<typename T> struct AnyCommandTraits {
  static const AnyCommand enum_value = AnyCommand_NONE;
};

template<> struct AnyCommandTraits<CommandLoadCache> {
  static const AnyCommand enum_value = AnyCommand_CommandLoadCache;
};

template<> struct AnyCommandTraits<CommandNewMaterial> {
  static const AnyCommand enum_value = AnyCommand_CommandNewMaterial;
};

template<> struct AnyCommandTraits<CommandNewShape> {
  static const AnyCommand enum_value = AnyCommand_CommandNewShape;
};

bool VerifyAnyCommand(flatbuffers::Verifier &verifier, const void *obj, AnyCommand type);
bool VerifyAnyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct BoxShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4
  };
  const Vector3f *size() const {
    return GetStruct<const Vector3f *>(VT_SIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vector3f>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct BoxShapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(const Vector3f *size) {
    fbb_.AddStruct(BoxShape::VT_SIZE, size);
  }
  explicit BoxShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoxShapeBuilder &operator=(const BoxShapeBuilder &);
  flatbuffers::Offset<BoxShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoxShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoxShape> CreateBoxShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector3f *size = 0) {
  BoxShapeBuilder builder_(_fbb);
  builder_.add_size(size);
  return builder_.Finish();
}

struct SphereShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIUS = 4
  };
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RADIUS) &&
           verifier.EndTable();
  }
};

struct SphereShapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_radius(float radius) {
    fbb_.AddElement<float>(SphereShape::VT_RADIUS, radius, 0.0f);
  }
  explicit SphereShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SphereShapeBuilder &operator=(const SphereShapeBuilder &);
  flatbuffers::Offset<SphereShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SphereShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<SphereShape> CreateSphereShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    float radius = 0.0f) {
  SphereShapeBuilder builder_(_fbb);
  builder_.add_radius(radius);
  return builder_.Finish();
}

struct CylinderShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHT = 4,
    VT_RAD = 6
  };
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  float rad() const {
    return GetField<float>(VT_RAD, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_RAD) &&
           verifier.EndTable();
  }
};

struct CylinderShapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(float height) {
    fbb_.AddElement<float>(CylinderShape::VT_HEIGHT, height, 0.0f);
  }
  void add_rad(float rad) {
    fbb_.AddElement<float>(CylinderShape::VT_RAD, rad, 0.0f);
  }
  explicit CylinderShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CylinderShapeBuilder &operator=(const CylinderShapeBuilder &);
  flatbuffers::Offset<CylinderShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CylinderShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<CylinderShape> CreateCylinderShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    float height = 0.0f,
    float rad = 0.0f) {
  CylinderShapeBuilder builder_(_fbb);
  builder_.add_rad(rad);
  builder_.add_height(height);
  return builder_.Finish();
}

struct Texture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4
  };
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           verifier.EndTable();
  }
};

struct TextureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(Texture::VT_FILENAME, filename);
  }
  explicit TextureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextureBuilder &operator=(const TextureBuilder &);
  flatbuffers::Offset<Texture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Texture>(end);
    return o;
  }
};

inline flatbuffers::Offset<Texture> CreateTexture(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0) {
  TextureBuilder builder_(_fbb);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<Texture> CreateTextureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return chrono::webgl::CreateTexture(
      _fbb,
      filename__);
}

struct Material FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLOR_DIFFUSE = 4,
    VT_COLOR_SPECULAR = 6,
    VT_TEXTURE_DIFFUSE = 8,
    VT_TEXTURE_SPECULAR = 10
  };
  const Color *color_diffuse() const {
    return GetStruct<const Color *>(VT_COLOR_DIFFUSE);
  }
  const Color *color_specular() const {
    return GetStruct<const Color *>(VT_COLOR_SPECULAR);
  }
  const Texture *texture_diffuse() const {
    return GetPointer<const Texture *>(VT_TEXTURE_DIFFUSE);
  }
  const Texture *texture_specular() const {
    return GetPointer<const Texture *>(VT_TEXTURE_SPECULAR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Color>(verifier, VT_COLOR_DIFFUSE) &&
           VerifyField<Color>(verifier, VT_COLOR_SPECULAR) &&
           VerifyOffset(verifier, VT_TEXTURE_DIFFUSE) &&
           verifier.VerifyTable(texture_diffuse()) &&
           VerifyOffset(verifier, VT_TEXTURE_SPECULAR) &&
           verifier.VerifyTable(texture_specular()) &&
           verifier.EndTable();
  }
};

struct MaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_color_diffuse(const Color *color_diffuse) {
    fbb_.AddStruct(Material::VT_COLOR_DIFFUSE, color_diffuse);
  }
  void add_color_specular(const Color *color_specular) {
    fbb_.AddStruct(Material::VT_COLOR_SPECULAR, color_specular);
  }
  void add_texture_diffuse(flatbuffers::Offset<Texture> texture_diffuse) {
    fbb_.AddOffset(Material::VT_TEXTURE_DIFFUSE, texture_diffuse);
  }
  void add_texture_specular(flatbuffers::Offset<Texture> texture_specular) {
    fbb_.AddOffset(Material::VT_TEXTURE_SPECULAR, texture_specular);
  }
  explicit MaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialBuilder &operator=(const MaterialBuilder &);
  flatbuffers::Offset<Material> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Material>(end);
    return o;
  }
};

inline flatbuffers::Offset<Material> CreateMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Color *color_diffuse = 0,
    const Color *color_specular = 0,
    flatbuffers::Offset<Texture> texture_diffuse = 0,
    flatbuffers::Offset<Texture> texture_specular = 0) {
  MaterialBuilder builder_(_fbb);
  builder_.add_texture_specular(texture_specular);
  builder_.add_texture_diffuse(texture_diffuse);
  builder_.add_color_specular(color_specular);
  builder_.add_color_diffuse(color_diffuse);
  return builder_.Finish();
}

struct CommandNewMaterial FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIAL_ID = 4,
    VT_MATERIAL = 6
  };
  uint64_t material_id() const {
    return GetField<uint64_t>(VT_MATERIAL_ID, 0);
  }
  const Material *material() const {
    return GetPointer<const Material *>(VT_MATERIAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MATERIAL_ID) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyTable(material()) &&
           verifier.EndTable();
  }
};

struct CommandNewMaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_material_id(uint64_t material_id) {
    fbb_.AddElement<uint64_t>(CommandNewMaterial::VT_MATERIAL_ID, material_id, 0);
  }
  void add_material(flatbuffers::Offset<Material> material) {
    fbb_.AddOffset(CommandNewMaterial::VT_MATERIAL, material);
  }
  explicit CommandNewMaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommandNewMaterialBuilder &operator=(const CommandNewMaterialBuilder &);
  flatbuffers::Offset<CommandNewMaterial> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommandNewMaterial>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommandNewMaterial> CreateCommandNewMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t material_id = 0,
    flatbuffers::Offset<Material> material = 0) {
  CommandNewMaterialBuilder builder_(_fbb);
  builder_.add_material_id(material_id);
  builder_.add_material(material);
  return builder_.Finish();
}

struct CommandModifyMaterial FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIAL_ID = 4,
    VT_MATERIAL = 6
  };
  uint64_t material_id() const {
    return GetField<uint64_t>(VT_MATERIAL_ID, 0);
  }
  const Material *material() const {
    return GetPointer<const Material *>(VT_MATERIAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MATERIAL_ID) &&
           VerifyOffset(verifier, VT_MATERIAL) &&
           verifier.VerifyTable(material()) &&
           verifier.EndTable();
  }
};

struct CommandModifyMaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_material_id(uint64_t material_id) {
    fbb_.AddElement<uint64_t>(CommandModifyMaterial::VT_MATERIAL_ID, material_id, 0);
  }
  void add_material(flatbuffers::Offset<Material> material) {
    fbb_.AddOffset(CommandModifyMaterial::VT_MATERIAL, material);
  }
  explicit CommandModifyMaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommandModifyMaterialBuilder &operator=(const CommandModifyMaterialBuilder &);
  flatbuffers::Offset<CommandModifyMaterial> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommandModifyMaterial>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommandModifyMaterial> CreateCommandModifyMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t material_id = 0,
    flatbuffers::Offset<Material> material = 0) {
  CommandModifyMaterialBuilder builder_(_fbb);
  builder_.add_material_id(material_id);
  builder_.add_material(material);
  return builder_.Finish();
}

struct CommandNewShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE_ID = 4,
    VT_SHAPE_TYPE = 6,
    VT_SHAPE = 8
  };
  uint64_t shape_id() const {
    return GetField<uint64_t>(VT_SHAPE_ID, 0);
  }
  AnyShape shape_type() const {
    return static_cast<AnyShape>(GetField<uint8_t>(VT_SHAPE_TYPE, 0));
  }
  const void *shape() const {
    return GetPointer<const void *>(VT_SHAPE);
  }
  template<typename T> const T *shape_as() const;
  const BoxShape *shape_as_BoxShape() const {
    return shape_type() == AnyShape_BoxShape ? static_cast<const BoxShape *>(shape()) : nullptr;
  }
  const SphereShape *shape_as_SphereShape() const {
    return shape_type() == AnyShape_SphereShape ? static_cast<const SphereShape *>(shape()) : nullptr;
  }
  const CylinderShape *shape_as_CylinderShape() const {
    return shape_type() == AnyShape_CylinderShape ? static_cast<const CylinderShape *>(shape()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SHAPE_ID) &&
           VerifyField<uint8_t>(verifier, VT_SHAPE_TYPE) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           VerifyAnyShape(verifier, shape(), shape_type()) &&
           verifier.EndTable();
  }
};

template<> inline const BoxShape *CommandNewShape::shape_as<BoxShape>() const {
  return shape_as_BoxShape();
}

template<> inline const SphereShape *CommandNewShape::shape_as<SphereShape>() const {
  return shape_as_SphereShape();
}

template<> inline const CylinderShape *CommandNewShape::shape_as<CylinderShape>() const {
  return shape_as_CylinderShape();
}

struct CommandNewShapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape_id(uint64_t shape_id) {
    fbb_.AddElement<uint64_t>(CommandNewShape::VT_SHAPE_ID, shape_id, 0);
  }
  void add_shape_type(AnyShape shape_type) {
    fbb_.AddElement<uint8_t>(CommandNewShape::VT_SHAPE_TYPE, static_cast<uint8_t>(shape_type), 0);
  }
  void add_shape(flatbuffers::Offset<void> shape) {
    fbb_.AddOffset(CommandNewShape::VT_SHAPE, shape);
  }
  explicit CommandNewShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommandNewShapeBuilder &operator=(const CommandNewShapeBuilder &);
  flatbuffers::Offset<CommandNewShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommandNewShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommandNewShape> CreateCommandNewShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t shape_id = 0,
    AnyShape shape_type = AnyShape_NONE,
    flatbuffers::Offset<void> shape = 0) {
  CommandNewShapeBuilder builder_(_fbb);
  builder_.add_shape_id(shape_id);
  builder_.add_shape(shape);
  builder_.add_shape_type(shape_type);
  return builder_.Finish();
}

struct CommandSetMaterial FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE_ID = 4,
    VT_MATERIAL_ID = 6
  };
  uint64_t shape_id() const {
    return GetField<uint64_t>(VT_SHAPE_ID, 0);
  }
  uint64_t material_id() const {
    return GetField<uint64_t>(VT_MATERIAL_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SHAPE_ID) &&
           VerifyField<uint64_t>(verifier, VT_MATERIAL_ID) &&
           verifier.EndTable();
  }
};

struct CommandSetMaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape_id(uint64_t shape_id) {
    fbb_.AddElement<uint64_t>(CommandSetMaterial::VT_SHAPE_ID, shape_id, 0);
  }
  void add_material_id(uint64_t material_id) {
    fbb_.AddElement<uint64_t>(CommandSetMaterial::VT_MATERIAL_ID, material_id, 0);
  }
  explicit CommandSetMaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommandSetMaterialBuilder &operator=(const CommandSetMaterialBuilder &);
  flatbuffers::Offset<CommandSetMaterial> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommandSetMaterial>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommandSetMaterial> CreateCommandSetMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t shape_id = 0,
    uint64_t material_id = 0) {
  CommandSetMaterialBuilder builder_(_fbb);
  builder_.add_material_id(material_id);
  builder_.add_shape_id(shape_id);
  return builder_.Finish();
}

struct CommandLoadCache FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILENAME = 4
  };
  const flatbuffers::String *filename() const {
    return GetPointer<const flatbuffers::String *>(VT_FILENAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           verifier.EndTable();
  }
};

struct CommandLoadCacheBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) {
    fbb_.AddOffset(CommandLoadCache::VT_FILENAME, filename);
  }
  explicit CommandLoadCacheBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommandLoadCacheBuilder &operator=(const CommandLoadCacheBuilder &);
  flatbuffers::Offset<CommandLoadCache> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CommandLoadCache>(end);
    return o;
  }
};

inline flatbuffers::Offset<CommandLoadCache> CreateCommandLoadCache(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0) {
  CommandLoadCacheBuilder builder_(_fbb);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<CommandLoadCache> CreateCommandLoadCacheDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr) {
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  return chrono::webgl::CreateCommandLoadCache(
      _fbb,
      filename__);
}

struct WebGLMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQUENCE = 4,
    VT_COMMAND_TYPE = 6,
    VT_COMMAND = 8
  };
  uint32_t sequence() const {
    return GetField<uint32_t>(VT_SEQUENCE, 0);
  }
  AnyCommand command_type() const {
    return static_cast<AnyCommand>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const CommandLoadCache *command_as_CommandLoadCache() const {
    return command_type() == AnyCommand_CommandLoadCache ? static_cast<const CommandLoadCache *>(command()) : nullptr;
  }
  const CommandNewMaterial *command_as_CommandNewMaterial() const {
    return command_type() == AnyCommand_CommandNewMaterial ? static_cast<const CommandNewMaterial *>(command()) : nullptr;
  }
  const CommandNewShape *command_as_CommandNewShape() const {
    return command_type() == AnyCommand_CommandNewShape ? static_cast<const CommandNewShape *>(command()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           VerifyAnyCommand(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
};

template<> inline const CommandLoadCache *WebGLMessage::command_as<CommandLoadCache>() const {
  return command_as_CommandLoadCache();
}

template<> inline const CommandNewMaterial *WebGLMessage::command_as<CommandNewMaterial>() const {
  return command_as_CommandNewMaterial();
}

template<> inline const CommandNewShape *WebGLMessage::command_as<CommandNewShape>() const {
  return command_as_CommandNewShape();
}

struct WebGLMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sequence(uint32_t sequence) {
    fbb_.AddElement<uint32_t>(WebGLMessage::VT_SEQUENCE, sequence, 0);
  }
  void add_command_type(AnyCommand command_type) {
    fbb_.AddElement<uint8_t>(WebGLMessage::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(WebGLMessage::VT_COMMAND, command);
  }
  explicit WebGLMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WebGLMessageBuilder &operator=(const WebGLMessageBuilder &);
  flatbuffers::Offset<WebGLMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WebGLMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<WebGLMessage> CreateWebGLMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t sequence = 0,
    AnyCommand command_type = AnyCommand_NONE,
    flatbuffers::Offset<void> command = 0) {
  WebGLMessageBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_sequence(sequence);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

struct WebGLMessageList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<WebGLMessage>> *message() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WebGLMessage>> *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyVector(message()) &&
           verifier.VerifyVectorOfTables(message()) &&
           verifier.EndTable();
  }
};

struct WebGLMessageListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WebGLMessage>>> message) {
    fbb_.AddOffset(WebGLMessageList::VT_MESSAGE, message);
  }
  explicit WebGLMessageListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WebGLMessageListBuilder &operator=(const WebGLMessageListBuilder &);
  flatbuffers::Offset<WebGLMessageList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WebGLMessageList>(end);
    return o;
  }
};

inline flatbuffers::Offset<WebGLMessageList> CreateWebGLMessageList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WebGLMessage>>> message = 0) {
  WebGLMessageListBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<WebGLMessageList> CreateWebGLMessageListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<WebGLMessage>> *message = nullptr) {
  auto message__ = message ? _fbb.CreateVector<flatbuffers::Offset<WebGLMessage>>(*message) : 0;
  return chrono::webgl::CreateWebGLMessageList(
      _fbb,
      message__);
}

inline bool VerifyAnyShape(flatbuffers::Verifier &verifier, const void *obj, AnyShape type) {
  switch (type) {
    case AnyShape_NONE: {
      return true;
    }
    case AnyShape_BoxShape: {
      auto ptr = reinterpret_cast<const BoxShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyShape_SphereShape: {
      auto ptr = reinterpret_cast<const SphereShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyShape_CylinderShape: {
      auto ptr = reinterpret_cast<const CylinderShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnyShapeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyShape(
        verifier,  values->Get(i), types->GetEnum<AnyShape>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyAnyCommand(flatbuffers::Verifier &verifier, const void *obj, AnyCommand type) {
  switch (type) {
    case AnyCommand_NONE: {
      return true;
    }
    case AnyCommand_CommandLoadCache: {
      auto ptr = reinterpret_cast<const CommandLoadCache *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyCommand_CommandNewMaterial: {
      auto ptr = reinterpret_cast<const CommandNewMaterial *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyCommand_CommandNewShape: {
      auto ptr = reinterpret_cast<const CommandNewShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnyCommandVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyCommand(
        verifier,  values->Get(i), types->GetEnum<AnyCommand>(i))) {
      return false;
    }
  }
  return true;
}

inline const chrono::webgl::WebGLMessageList *GetWebGLMessageList(const void *buf) {
  return flatbuffers::GetRoot<chrono::webgl::WebGLMessageList>(buf);
}

inline const chrono::webgl::WebGLMessageList *GetSizePrefixedWebGLMessageList(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<chrono::webgl::WebGLMessageList>(buf);
}

inline bool VerifyWebGLMessageListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<chrono::webgl::WebGLMessageList>(nullptr);
}

inline bool VerifySizePrefixedWebGLMessageListBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<chrono::webgl::WebGLMessageList>(nullptr);
}

inline void FinishWebGLMessageListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<chrono::webgl::WebGLMessageList> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedWebGLMessageListBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<chrono::webgl::WebGLMessageList> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace webgl
}  // namespace chrono

#endif  // FLATBUFFERS_GENERATED_ASSETS_CHRONO_WEBGL_H_
